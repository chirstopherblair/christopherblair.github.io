<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 7.1.1">

  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.1/css/all.min.css" integrity="sha256-wiz7ZSCn/btzhjKDQBms9Hx4sSeUYsDrTLg7roPstac=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"example.com","root":"/","images":"/images","scheme":"Muse","darkmode":false,"version":"8.19.2","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":{"enable":false,"style":null},"fold":{"enable":false,"height":500},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"i18n":{"placeholder":"Searching...","empty":"We didn't find any results for the search: ${query}","hits_time":"${hits} results found in ${time} ms","hits":"${hits} results found"}}</script><script src="/js/config.js"></script>

    <meta name="description" content="重新系统学习cpp基础 ###类与对象 在C++中，类是一种用户自定义的数据类型，用于封装数据和相关操作。它可以看作是一个模板或蓝图，描述了对象的属性（成员变量）和行为（成员函数）。要定义一个类，可以使用class关键字后跟类名，并在大括号中定义类的成员变量和成员函数。例如： 12345678class MyClass &#123;  private:    int myVariable; &#x2F;&#x2F;">
<meta property="og:type" content="article">
<meta property="og:title" content="cpp基础">
<meta property="og:url" content="http://example.com/2021/09/03/c++/index.html">
<meta property="og:site_name" content="Christopherblair&#39;s blog">
<meta property="og:description" content="重新系统学习cpp基础 ###类与对象 在C++中，类是一种用户自定义的数据类型，用于封装数据和相关操作。它可以看作是一个模板或蓝图，描述了对象的属性（成员变量）和行为（成员函数）。要定义一个类，可以使用class关键字后跟类名，并在大括号中定义类的成员变量和成员函数。例如： 12345678class MyClass &#123;  private:    int myVariable; &#x2F;&#x2F;">
<meta property="og:locale" content="en_US">
<meta property="article:published_time" content="2021-09-02T16:00:00.000Z">
<meta property="article:author" content="John Doe">
<meta property="article:tag" content="c++">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="http://example.com/2021/09/03/c++/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"en","comments":true,"permalink":"http://example.com/2021/09/03/c++/","path":"2021/09/03/c++/","title":"cpp基础"}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>cpp基础 | Christopherblair's blog</title>
  








  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar" role="button">
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <p class="site-title">Christopherblair's blog</p>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="Search" role="button">
    </div>
  </div>
</div>







</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-overview-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">John Doe</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">2</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
        <span class="site-state-item-count">1</span>
        <span class="site-state-item-name">categories</span>
      </div>
      <div class="site-state-item site-state-tags">
        <span class="site-state-item-count">2</span>
        <span class="site-state-item-name">tags</span>
      </div>
  </nav>
</div>

        </div>
      </div>
    </div>

    
  </aside>


    </div>

    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/09/03/c++/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Christopherblair's blog">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="cpp基础 | Christopherblair's blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          cpp基础
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2021-09-03 00:00:00" itemprop="dateCreated datePublished" datetime="2021-09-03T00:00:00+08:00">2021-09-03</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Diary/" itemprop="url" rel="index"><span itemprop="name">Diary</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody"><p>重新系统学习cpp基础</p>
<p>###类与对象</p>
<p>在C++中，类是一种用户自定义的数据类型，用于封装数据和相关操作。它可以看作是一个模板或蓝图，描述了对象的属性（成员变量）和行为（成员函数）。要定义一个类，可以使用class关键字后跟类名，并在大括号中定义类的成员变量和成员函数。例如：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">class MyClass &#123;</span><br><span class="line">  private:</span><br><span class="line">    int myVariable; // 成员变量</span><br><span class="line"></span><br><span class="line">  public:</span><br><span class="line">    void myFunction(); // 成员函数</span><br><span class="line">&#125;;</span><br><span class="line">MyClass obj; // 实例化一个 MyClass 对象</span><br></pre></td></tr></table></figure>
<span id="more"></span>

<p>构造函数可传参</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">class MyClass &#123;</span><br><span class="line">  private:</span><br><span class="line">    int myVariable;</span><br><span class="line"></span><br><span class="line">  public:</span><br><span class="line">    MyClass(int value) &#123; // 构造函数</span><br><span class="line">        myVariable = value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">// 创建对象并传递参数进行初始化</span><br><span class="line">MyClass obj(10);</span><br></pre></td></tr></table></figure>

<p>###继承与多态<br>  在C++中，继承是一种机制，允许一个类（称为子类或派生类）从另一个已存在的类（称为基类或父类）继承属性和行为。子类可以继承基类的成员变量和成员函数，并且还可以添加自己特有的成员变量和成员函数。通过使用冒号（:）来指定继承关系，并指定要从哪个基类继承，以及继承类型（公有、私有或保护）。例如：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">class BaseClass &#123;</span><br><span class="line">  // 基类定义</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class DerivedClass : access-specifier BaseClass &#123;</span><br><span class="line">  // 派生类定义</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p> 其中，access-specifier 可以是 public、private 或 protected，表示派生类对基类的访问权限。</p>
<p> 多态性是面向对象编程中的一个概念，它允许同样的函数接口在不同的对象上表现出不同的行为。C++ 中实现多态性主要依靠虚函数（virtual functions）和动态绑定。虚函数是在基类中声明并用 virtual 关键字进行标记的成员函数。派生类可以覆盖该虚函数，并根据需要提供自己的实现。通过使用指向基类对象的指针或引用调用虚函数时，程序将根据运行时实际对象类型来确定要调用的函数。<br> 例如：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">class Shape &#123;</span><br><span class="line">  public:</span><br><span class="line">    virtual void <span class="function"><span class="title">draw</span></span>() &#123;</span><br><span class="line">        // 基类虚函数的默认实现</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;绘制图形&quot;</span> &lt;&lt; <span class="string">endl;</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">&#125;;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">class Circle : public Shape &#123;</span></span><br><span class="line"><span class="string">  public:</span></span><br><span class="line"><span class="string">    void draw() &#123;</span></span><br><span class="line"><span class="string">        // 派生类对虚函数的覆盖实现</span></span><br><span class="line"><span class="string">        cout &lt;&lt; &quot;绘制圆形&quot; &lt;&lt; endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class Rectangle : public Shape &#123;</span><br><span class="line">  public:</span><br><span class="line">    void <span class="function"><span class="title">draw</span></span>() &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;绘制矩形&quot;</span> &lt;&lt; <span class="string">endl;</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">&#125;;</span></span><br></pre></td></tr></table></figure>

<p>在上述代码中，Shape 类具有一个名为 draw() 的虚函数。派生类 Circle 和 Rectangle 都对该函数进行了覆盖。</p>
<p>通过使用基类指针或引用来调用 draw() 函数时，可以根据指向的对象类型来决定实际执行哪个版本的函数：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Shape* shapePtr;</span><br><span class="line"></span><br><span class="line">Circle circle;</span><br><span class="line">Rectangle rectangle;</span><br><span class="line"></span><br><span class="line">shapePtr = &amp;circle;</span><br><span class="line">shapePtr-&gt;draw(); // 调用 Circle 类中的 draw() 函数</span><br><span class="line"></span><br><span class="line">shapePtr = &amp;rectangle;</span><br><span class="line">shapePtr-&gt;draw(); // 调用 Rectangle 类中的 draw() 函数</span><br></pre></td></tr></table></figure>
<p> 虚函数是在基类中声明并用 virtual 关键字进行标记的成员函数。它在面向对象编程中扮演重要角色，允许派生类对该函数进行覆盖，并根据实际运行时对象类型来确定要调用的函数。</p>
<p> 使用虚函数的主要目的是实现多态性。多态性允许同样的函数接口在不同的对象上表现出不同的行为。通过将函数声明为虚函数，可以在基类中定义一个通用的接口，并且允许派生类根据自己特定需求提供不同的实现。</p>
<p> 当我们使用指向基类对象的指针或引用调用一个虚函数时，程序会根据运行时实际对象类型来确定要调用哪个版本的函数。这种动态绑定机制使得程序能够在运行时根据实际对象类型选择相应的函数，而不是在编译时就静态地决定。</p>
<p> 使用虚函数有以下几个优点：</p>
<p> 实现多态性：通过使用虚函数，可以创建一个统一接口，以便处理具有不同类型但具有相似功能和行为的对象。<br> 简化代码逻辑：通过将通用操作放在基类中定义，并使用派生类覆盖特定功能，可以减少代码冗余并提高可维护性。<br> 扩展性和灵活性：通过添加新的派生类并覆盖虚函数，可以轻松地扩展和修改现有的代码结构。</p>
<p> ###封装</p>
<p> 封装（Encapsulation）：封装是将数据和操作（方法）包装在一个单元（类）中，以实现数据的隐藏和保护。通过封装，我们可以将数据隐藏在类内部，并提供公共接口来访问和操作这些数据，从而实现了信息隐藏、数据安全性和代码模块化的目标。</p>
<figure class="highlight plaintext"><figcaption><span>Circle &#123;</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">private:</span><br><span class="line">  double radius;</span><br><span class="line"></span><br><span class="line">public:</span><br><span class="line">  void setRadius(double r) &#123;</span><br><span class="line">    if (r &gt; 0) &#123;</span><br><span class="line">      radius = r;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  double getRadius() &#123;</span><br><span class="line">    return radius;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  double calculateArea() &#123;</span><br><span class="line">    return 3.14 * radius * radius;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p> 在上述代码中，radius 是私有成员变量，外部无法直接访问。通过 setRadius() 和 getRadius() 方法，可以对半径进行设置和获取。同时，calculateArea() 方法用于计算圆的面积。</p>
<p> 继承（Inheritance）：继承允许一个类派生出子类，并从父类继承其属性和行为。子类可以使用父类已有的特性，并根据需要添加自己独特的属性和方法。通过继承机制，可以实现代码重用、层次结构组织等目标。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">class Shape &#123; </span><br><span class="line">protected: // 使用 protected 访问修饰符</span><br><span class="line">  double width;</span><br><span class="line">  double height;</span><br><span class="line"></span><br><span class="line">public:</span><br><span class="line">  void setDimensions(double w, double h) &#123;</span><br><span class="line">    width = w;</span><br><span class="line">    height = h;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class Rectangle : public Shape &#123; </span><br><span class="line">public:</span><br><span class="line">  double calculateArea() &#123;</span><br><span class="line">    return width * height;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class Triangle : public Shape &#123; </span><br><span class="line">public:</span><br><span class="line">  double calculateArea() &#123;</span><br><span class="line">    return (width * height) / 2;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p> ###内存泄漏</p>
<p> 如malloc后没有free，cpp中动态内存分配通过new和delete操作符来实现</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">int* ptr = new int; // 分配一个整型变量的内存空间</span><br><span class="line">double* arr = new double[10]; // 分配一个包含10个双精度浮点数的数组的内存空间</span><br><span class="line">delete ptr; // 释放之前通过new分配的单个变量的内存空间</span><br><span class="line">delete[] arr; // 释放之前通过new[]分配的数组的内存空间</span><br></pre></td></tr></table></figure>
<p> 在使用new操作符时，它会根据类型动态地为对象或数组分配合适大小的内存，并返回指向该内存块起始地址的指针。对于基本类型或自定义对象，可以使用相应类型的指针来接收这个返回值。当不再需要动态分配的内存时，应使用delete操作符将其释放。对于通过new[]操作符创建的数组，必须使用delete[]进行释放。</p>
<p> 如何处理内存泄漏问题<br>1、显式释放内存：在使用动态分配的内存（如new、malloc）后，务必及时使用相应的释放操作（如delete、free）来手动释放已分配的内存。确保每次动态分配都有相应的释放操作与之对应。<br>2、智能指针（Smart Pointers）：使用智能指针可以自动管理内存资源，避免显式地调用释放操作。C++中提供了 std::shared_ptr 和 std::unique_ptr 两种智能指针，它们可以在对象不再被引用时自动释放相关内存。<br>3、RAII（Resource Acquisition Is Initialization）：RAII 是一种编程范式，在对象构造函数中获取资源，在析构函数中进行资源的释放。通过利用栈上对象生命周期结束时自动调用析构函数的特性，可以确保资源得到正确和及时地释放。<br>4、定期检查和测试：定期进行代码审查和测试，尤其关注内存分配和释放部分是否正确。使用工具或手动方法检测潜在的内存泄漏情况，并进行修复。<br>5、使用容器类和标准库：使用现代化的容器类和标准库算法可以简化内存管理工作。例如，使用 std::vector 替代手动管理数组内存，使用 std::string 替代手动管理字符串内存等。<br>6、遵循编码规范：良好的编码规范和设计原则有助于避免内存泄漏问题。例如，避免多层级的指针引用、避免过度复杂的嵌套结构、合理地处理异常情况等。<br>7、内存分析工具：使用专门的内存分析工具（如Valgrind、AddressSanitizer）来检测和诊断程序中的内存泄漏问题。这些工具可以帮助发现潜在的资源未释放或访问无效内存等情况。</p>
<p> ###析构函数</p>
<p>~classname()</p>
<p> 析构函数是在C++类中的一个特殊成员函数，它与类名相同但前面加上波浪号（~），用于在对象生命周期结束时进行清理和资源释放。作用：</p>
<p>1、资源释放：析构函数可以用来释放对象所占有的资源，如动态分配的内存、打开的文件、建立的连接等。这样可以确保在对象销毁时相关资源得到正确释放，避免内存泄漏或资源泄漏。<br>2、清理操作：如果对象在创建过程中进行了一些初始化操作，在析构函数中可以进行相应的清理操作，将对象恢复到初始状态。<br>3、继承关系下的调用顺序：当存在继承关系时，派生类的析构函数会自动调用基类的析构函数，以便逐层清理各个父类的资源。</p>
<p> ###const，声明常量，不可修改。可以应用于变量、函数参数、函数返回值和成员函数。</p>
<p> ###&amp;和*</p>
<p>语法：声明一个引用使用&amp;符号，而声明一个指针使用*符号。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">int num = 10; int&amp; ref = num; // 引用 </span><br><span class="line">int* ptr = &amp;num; // 指针</span><br></pre></td></tr></table></figure>
<p>初始化：引用必须在声明时进行初始化，并且一旦初始化后不能改变其绑定的对象；指针可以在任何时候进行初始化，并且可以修改指向的对象。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">int num = 10; </span><br><span class="line">int&amp; ref = num; // 引用初始化 </span><br><span class="line">int* ptr; // 指针声明 </span><br><span class="line">ptr = &amp;num; // 指针赋值 </span><br><span class="line">ref = 20; // 正确，修改了num的值 </span><br><span class="line">*ptr = 30; // 正确，也会修改num的值</span><br></pre></td></tr></table></figure>
<p>空值（null）：指针可以具有空值（nullptr），表示未指向任何有效对象；引用没有空值，必须在初始化时绑定到一个有效对象上。<br>内存地址操作：指针可以进行内存地址的算术运算（如加法、减法等），并且可以通过解引用操作符（*）访问所指向的对象；引用不直接支持内存地址操作和解引用操作符，它是被绑定对象的别名。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">int num = 10; int* ptr = &amp;num; // 指针 </span><br><span class="line">ptr++; // 正确，指针进行地址运算 </span><br><span class="line">*ptr = 20; // 正确，通过解引用修改所指向的对象 </span><br><span class="line">int&amp; ref = num; // 引用// </span><br><span class="line">ref++; // 错误，引用不支持地址运算 </span><br><span class="line">ref = 30; // 正确，直接修改了num的值</span><br></pre></td></tr></table></figure>

<p> ###template,泛型编程</p>
<p> 模板类</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">template &lt;typename T&gt;</span><br><span class="line">class Container &#123;</span><br><span class="line">private:</span><br><span class="line">    T data;</span><br><span class="line"></span><br><span class="line">public:</span><br><span class="line">    Container(T value) : data(value) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    void print() &#123;</span><br><span class="line">        std::cout &lt;&lt; &quot;Data: &quot; &lt;&lt; data &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p> 模板函数</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">template &lt;typename T&gt;</span><br><span class="line">T maximum(T a, T b) &#123;</span><br><span class="line">    return (a &gt; b) ? a : b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> ###static，静态成员<br> 静态成员变量是属于类本身的变量，而不是每个对象独有的。所有该类的对象共享同一个静态成员变量的内存空间。可以通过类名加作用域运算符来访问静态成员变量，无需创建对象实例。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">class MyClass &#123;</span><br><span class="line">public:</span><br><span class="line">    static int count;  // 静态成员变量</span><br><span class="line"></span><br><span class="line">    MyClass() &#123;</span><br><span class="line">        count++;  // 在构造函数中对静态成员变量进行操作</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int MyClass::count = 0;  // 静态成员变量初始化</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    MyClass obj1;</span><br><span class="line">    MyClass obj2;</span><br><span class="line">    </span><br><span class="line">    cout &lt;&lt; &quot;Count: &quot; &lt;&lt; MyClass::count &lt;&lt; endl;  // 访问静态成员变量</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出结果为：Count: 2。这说明两个对象共享同一个静态成员变量 count，并且通过类名进行访问。</p>
<p> 静态成员函数（Static Member Functions）： 静态成员函数与类相关联，而不是与具体的对象实例相关联。它们可以通过类名直接调用，无需创建对象实例，并且只能访问静态成员变量和其他静态成员函数。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">class MyClass &#123;</span><br><span class="line">public:</span><br><span class="line">    static void printCount() &#123;  // 静态成员函数</span><br><span class="line">        cout &lt;&lt; &quot;Count: &quot; &lt;&lt; count &lt;&lt; endl;  // 访问静态成员变量</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">private:</span><br><span class="line">    static int count;  // 静态成员变量</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int MyClass::count = 0;  // 静态成员变量初始化</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    MyClass::printCount();  // 调用静态成员函数</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出结果为：Count: 0。通过类名直接调用静态成员函数，可以访问并操作静态成员变量。</p>
<p> ###STL标准库</p>
<p> vector: vector 是一个动态数组，可以在运行时自动扩展和收缩大小。它以连续的内存块存储元素，支持随机访问、尾部插入和删除等操作。<br> list: list 是一个双向链表，每个节点包含指向前一个节点和后一个节点的指针。相比于 vector，list 在任意位置进行插入和删除操作更高效，但对于随机访问则较慢。<br> deque: deque（双端队列）也是一个动态数组，与 vector 类似，但支持在首尾两端进行高效插入和删除操作。<br> stack: stack 是一个后进先出（LIFO）的容器适配器，基于其他底层容器实现。它只允许在末尾进行元素插入和删除，并且只能访问最顶端的元素。<br> queue: queue 是一个先进先出（FIFO）的容器适配器，在尾部插入数据，在头部移除数据。与 stack 类似，它也基于其他底层容器实现。<br> map: map 是一种关联容器，存储一对键-值对。它根据键来进行排序和查找，具有较快的插入和删除操作。每个键在容器中是唯一的。<br> set: set 是另一种关联容器，存储唯一的值（不重复）。它自动将元素排序，并支持高效地插入、查找和删除操作。<br> unordered_map: unordered_map 是基于哈希表实现的关联容器，通过哈希函数来存储和访问元素。相比于 map，它的插入和查找操作通常更快，但不保证元素的顺序。<br> unordered_set: unordered_set 也是基于哈希表实现的集合容器，存储唯一的值并支持高效地插入、查找和删除操作。</p>
<p> ###iterator迭代器，用于遍历容器中元素，迭代器类似于指针，提供了对容器中元素的访问、遍历和操作功能。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    std::vector&lt;int&gt; numbers = &#123;1, 2, 3, 4, 5&#125;;</span><br><span class="line"></span><br><span class="line">    // 使用迭代器进行遍历</span><br><span class="line">    std::vector&lt;int&gt;::iterator it;  // 声明一个迭代器变量</span><br><span class="line"></span><br><span class="line">    for (it = numbers.begin(); it != numbers.end(); ++it) &#123;</span><br><span class="line">        std::cout &lt;&lt; *it &lt;&lt; &quot; &quot;;  // 通过解引用操作符 * 访问当前迭代位置的元素</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

    </div>

    
    
    

    <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/c/" rel="tag"># c++</a>
          </div>

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/2021/03/26/qt&Boost.asio/" rel="prev" title="QLogger：Qt 多线程记录器">
                  <i class="fa fa-angle-left"></i> QLogger：Qt 多线程记录器
                </a>
            </div>
            <div class="post-nav-item">
            </div>
          </div>
    </footer>
  </article>
</div>






</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">

  <div class="copyright">
    &copy; 
    <span itemprop="copyrightYear">2024</span>
    <span class="with-love">
      <i class="fa fa-heart"></i>
    </span>
    <span class="author" itemprop="copyrightHolder">John Doe</span>
  </div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/muse/" rel="noopener" target="_blank">NexT.Muse</a>
  </div>

    </div>
  </footer>

  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>
  <div class="sidebar-dimmer"></div>
  <div class="back-to-top" role="button" aria-label="Back to top">
    <i class="fa fa-arrow-up fa-lg"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/schemes/muse.js"></script><script src="/js/next-boot.js"></script>

  






  





</body>
</html>
